{"dependencies":[{"name":"/Users/sanghan/Desktop/tfjs-examples/mobilenet/package.json","includedInParent":true,"mtime":1522644996454},{"name":"/Users/sanghan/Desktop/tfjs-examples/mobilenet/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":1522260134000},{"name":"underscore","loc":{"line":13,"column":16}},{"name":"../backend/tfjs_backend","loc":{"line":14,"column":16}},{"name":"../engine/topology","loc":{"line":15,"column":25}},{"name":"../errors","loc":{"line":16,"column":23}},{"name":"../utils/generic_utils","loc":{"line":17,"column":28}},{"name":"../utils/math_utils","loc":{"line":18,"column":24}}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"underscore\");\nvar K = require(\"../backend/tfjs_backend\");\nvar topology_1 = require(\"../engine/topology\");\nvar errors_1 = require(\"../errors\");\nvar generic_utils = require(\"../utils/generic_utils\");\nvar mathUtils = require(\"../utils/math_utils\");\nvar Merge = (function (_super) {\n    __extends(Merge, _super);\n    function Merge(config) {\n        var _this = _super.call(this, config || {}) || this;\n        _this.supportsMasking = true;\n        return _this;\n    }\n    Merge.prototype.mergeFunction = function (inputs) {\n        throw new errors_1.NotImplementedError();\n    };\n    Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {\n        if (shape1 == null || shape2 == null) {\n            return null;\n        }\n        else if (shape1.length < shape2.length) {\n            return this.computeElementwiseOpOutputShape(shape2, shape1);\n        }\n        else if (shape2.length === 0) {\n            return shape1;\n        }\n        var outputShape = shape1.slice(0, shape1.length - shape2.length);\n        for (var k = 0; k < shape2.length; ++k) {\n            var i = shape1[shape1.length - shape2.length + k];\n            var j = shape2[k];\n            if (i == null || j == null || i < 0 || j < 0) {\n                outputShape.push(null);\n            }\n            else if (i === 1) {\n                outputShape.push(j);\n            }\n            else if (j === 1) {\n                outputShape.push(i);\n            }\n            else {\n                if (i !== j) {\n                    throw new errors_1.ValueError('Operands could not be broadcast together with shapes ' +\n                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n                }\n                outputShape.push(i);\n            }\n        }\n        return outputShape;\n    };\n    Merge.prototype.build = function (inputShape) {\n        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n            inputShape = [generic_utils.getExactlyOneShape(inputShape)];\n        }\n        inputShape = inputShape;\n        if (inputShape.length < 2) {\n            throw new errors_1.ValueError('A merge layer should be called on an Array of at least 2 inputs.' +\n                (\" Got \" + inputShape.length + \" input(s).\"));\n        }\n        var batchSizes = [];\n        for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {\n            var shape = inputShape_1[_i];\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = _.uniq(batchSizes);\n        if (batchSizes.length > 1) {\n            throw new errors_1.ValueError(\"Can not merge tensors with different batch sizes. \" +\n                (\"Got tensors with shapes: \" + JSON.stringify(inputShape) + \".\"));\n        }\n        var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n        for (var i = 1; i < inputShape.length; ++i) {\n            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        var allRanks = inputShape.map(function (shape) { return shape.length; });\n        if (!_.contains(inputShape, null) && _.uniq(allRanks).length === 1) {\n            this.reshapeRequired = false;\n        }\n        else {\n            this.reshapeRequired = true;\n        }\n    };\n    Merge.prototype.call = function (inputs, kwargs) {\n        inputs = inputs;\n        if (this.reshapeRequired) {\n            var reshapedInputs = [];\n            var inputDims = inputs.map(function (input) { return K.ndim(input); });\n            if (!_.contains(inputDims, null)) {\n                var maxNDim = _.max(inputDims);\n                for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n                    var x = inputs_1[_i];\n                    var xNDim = K.ndim(x);\n                    for (var k = 0; k < maxNDim - xNDim; ++k) {\n                        x = K.expandDims(x, 1);\n                    }\n                    reshapedInputs.push(x);\n                }\n                return this.mergeFunction(reshapedInputs);\n            }\n            else {\n                var transposed = false;\n                for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {\n                    var x = inputs_2[_a];\n                    var xNDim = K.ndim(x);\n                    if (xNDim == null) {\n                        var xShape = K.shape(x);\n                        var batchSize = xShape[0];\n                        var newShape = xShape.slice(1).concat([batchSize]);\n                        var xTransposed = K.reshape(x, [batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n                        xTransposed = K.permuteDimensions(xTransposed, [1, 0]);\n                        xTransposed = K.reshape(xTransposed, newShape);\n                        reshapedInputs.push(xTransposed);\n                        transposed = true;\n                    }\n                    else if (xNDim > 1) {\n                        var dims = _.range(1, xNDim).concat([0]);\n                        reshapedInputs.push(K.permuteDimensions(x, dims));\n                        transposed = true;\n                    }\n                    else {\n                        reshapedInputs.push(x);\n                    }\n                }\n                var y = this.mergeFunction(reshapedInputs);\n                var yNDim = K.ndim(y);\n                if (transposed) {\n                    if (yNDim == null) {\n                        var yShape = K.shape(y);\n                        var yNDim_1 = yShape.length;\n                        var batchSize = yShape[yNDim_1 - 1];\n                        var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n                        y = K.reshape(K.permuteDimensions(K.reshape(y, [-1, batchSize]), [1, 0]), newShape);\n                    }\n                    else if (yNDim > 1) {\n                        var dims = [yNDim - 1].concat(_.range(0, yNDim - 1));\n                        y = K.permuteDimensions(y, dims);\n                    }\n                }\n                return y;\n            }\n        }\n        else {\n            return this.mergeFunction(inputs);\n        }\n    };\n    Merge.prototype.computeOutputShape = function (inputShape) {\n        inputShape = inputShape;\n        var outputShape;\n        if (inputShape[0] == null) {\n            outputShape = null;\n        }\n        else {\n            outputShape = inputShape[0].slice(1);\n        }\n        for (var i = 1; i < inputShape.length; ++i) {\n            var shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        var batchSizes = [];\n        for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {\n            var shape = inputShape_2[_i];\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = _.uniq(batchSizes);\n        if (batchSizes.length === 1) {\n            outputShape = batchSizes.concat(outputShape);\n        }\n        else {\n            outputShape = [null].concat(outputShape);\n        }\n        return outputShape;\n    };\n    return Merge;\n}(topology_1.Layer));\nexports.Merge = Merge;\nvar Add = (function (_super) {\n    __extends(Add, _super);\n    function Add(config) {\n        return _super.call(this, config) || this;\n    }\n    Add.prototype.mergeFunction = function (inputs) {\n        var output = K.zeros(inputs[0].shape);\n        for (var _i = 0, inputs_3 = inputs; _i < inputs_3.length; _i++) {\n            var input = inputs_3[_i];\n            output = K.add(output, input);\n        }\n        return output;\n    };\n    return Add;\n}(Merge));\nexports.Add = Add;\ngeneric_utils.ClassNameMap.register('Add', Add);\nfunction add(config) {\n    if (Array.isArray(config)) {\n        var layer = new Add({});\n        return layer.apply(config);\n    }\n    else {\n        return new Add(config);\n    }\n}\nexports.add = add;\nvar Multiply = (function (_super) {\n    __extends(Multiply, _super);\n    function Multiply(config) {\n        return _super.call(this, config) || this;\n    }\n    Multiply.prototype.mergeFunction = function (inputs) {\n        var output = K.ones(inputs[0].shape);\n        for (var _i = 0, inputs_4 = inputs; _i < inputs_4.length; _i++) {\n            var input = inputs_4[_i];\n            output = K.multiply(output, input);\n        }\n        return output;\n    };\n    return Multiply;\n}(Merge));\nexports.Multiply = Multiply;\ngeneric_utils.ClassNameMap.register('Multiply', Multiply);\nfunction multiply(config) {\n    if (Array.isArray(config)) {\n        var layer = new Multiply({});\n        return layer.apply(config);\n    }\n    else {\n        return new Multiply(config);\n    }\n}\nexports.multiply = multiply;\nvar Average = (function (_super) {\n    __extends(Average, _super);\n    function Average(config) {\n        return _super.call(this, config) || this;\n    }\n    Average.prototype.mergeFunction = function (inputs) {\n        var output = K.zeros(inputs[0].shape);\n        for (var _i = 0, inputs_5 = inputs; _i < inputs_5.length; _i++) {\n            var input = inputs_5[_i];\n            output = K.add(output, input);\n        }\n        return K.scalarTimesArray(K.getScalar(1 / inputs.length), output);\n    };\n    return Average;\n}(Merge));\nexports.Average = Average;\ngeneric_utils.ClassNameMap.register('Average', Average);\nfunction average(config) {\n    if (Array.isArray(config)) {\n        var layer = new Average({});\n        return layer.apply(config);\n    }\n    else {\n        return new Average(config);\n    }\n}\nexports.average = average;\nvar Maximum = (function (_super) {\n    __extends(Maximum, _super);\n    function Maximum(config) {\n        return _super.call(this, config) || this;\n    }\n    Maximum.prototype.mergeFunction = function (inputs) {\n        var output = inputs[0];\n        for (var i = 1; i < inputs.length; ++i) {\n            output = K.maximum(output, inputs[i]);\n        }\n        return output;\n    };\n    return Maximum;\n}(Merge));\nexports.Maximum = Maximum;\ngeneric_utils.ClassNameMap.register('Maximum', Maximum);\nfunction maximum(config) {\n    if (Array.isArray(config)) {\n        var layer = new Maximum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Maximum(config);\n    }\n}\nexports.maximum = maximum;\nvar Minimum = (function (_super) {\n    __extends(Minimum, _super);\n    function Minimum(config) {\n        return _super.call(this, config) || this;\n    }\n    Minimum.prototype.mergeFunction = function (inputs) {\n        var output = inputs[0];\n        for (var i = 1; i < inputs.length; ++i) {\n            output = K.minimum(output, inputs[i]);\n        }\n        return output;\n    };\n    return Minimum;\n}(Merge));\nexports.Minimum = Minimum;\ngeneric_utils.ClassNameMap.register('Minimum', Minimum);\nfunction minimum(config) {\n    if (Array.isArray(config)) {\n        var layer = new Minimum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Minimum(config);\n    }\n}\nexports.minimum = minimum;\nvar Concatenate = (function (_super) {\n    __extends(Concatenate, _super);\n    function Concatenate(config) {\n        var _this = _super.call(this, config) || this;\n        _this.DEFAULT_AXIS = -1;\n        if (config == null) {\n            config = {};\n        }\n        _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;\n        _this.supportsMasking = true;\n        _this.reshapeRequired = false;\n        return _this;\n    }\n    Concatenate.prototype.build = function (inputShape) {\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||\n            inputShape.length === 1) {\n            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +\n                'inputs');\n        }\n        inputShape = inputShape;\n        var allNoneShape = true;\n        for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {\n            var shape = inputShape_3[_i];\n            if (shape != null) {\n                allNoneShape = false;\n                break;\n            }\n        }\n        if (allNoneShape) {\n            return;\n        }\n        var shapeSet = [];\n        for (var i = 0; i < inputShape.length; ++i) {\n            var shapeWithoutConcatAxis = inputShape[i].slice();\n            shapeWithoutConcatAxis.splice(this.axis, 1);\n            var exists = false;\n            for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {\n                var shape = shapeSet_1[_a];\n                if (_.isEqual(shape, shapeWithoutConcatAxis)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                shapeSet.push(shapeWithoutConcatAxis);\n            }\n        }\n        if (shapeSet.length > 1) {\n            throw new errors_1.ValueError('A `Concatenate` layer requires inputs with matching shapes ' +\n                'except for the concat axis. Got input shapes: ' +\n                JSON.stringify(inputShape));\n        }\n    };\n    Concatenate.prototype.mergeFunction = function (inputs) {\n        return K.concatenate(inputs, this.axis);\n    };\n    Concatenate.prototype.computeOutputShape = function (inputShape) {\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n            throw new errors_1.ValueError('A `Concatenate` layer should be called on a list of inputs.');\n        }\n        var inputShapes = inputShape;\n        var outputShape = inputShapes[0].slice();\n        var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n        for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {\n            var shape = _a[_i];\n            if (outputShape[axis] == null || shape[axis] == null) {\n                outputShape[axis] = null;\n                break;\n            }\n            outputShape[axis] += shape[axis];\n        }\n        return outputShape;\n    };\n    return Concatenate;\n}(Merge));\nexports.Concatenate = Concatenate;\ngeneric_utils.ClassNameMap.register('Concatenate', Concatenate);\nfunction concatenate(config) {\n    if (Array.isArray(config)) {\n        var layer = new Concatenate({});\n        return layer.apply(config);\n    }\n    else {\n        return new Concatenate(config);\n    }\n}\nexports.concatenate = concatenate;\n"},"hash":"4c37d0cc360d5ef52ac9c00241885c13","cacheData":{"env":{}}}